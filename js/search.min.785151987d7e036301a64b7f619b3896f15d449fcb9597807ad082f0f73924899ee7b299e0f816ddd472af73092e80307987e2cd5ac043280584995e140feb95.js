!function(){var t,l,c,e,r,h,d,f,p,y,m,g,x,v,w,Q,k,S,E,L,b,P,T,O,I,i,n,z=function(e){var t=new z.Builder;return t.pipeline.add(z.trimmer,z.stopWordFilter,z.stemmer),t.searchPipeline.add(z.stemmer),e.call(t,t),t.build()};function s(e){var t,r,i,n,s,o,a;if(e.length<3)return e;if("y"==(i=e.substr(0,1))&&(e=i.toUpperCase()+e.substr(1)),s=m,(n=y).test(e)?e=e.replace(n,"$1$2"):s.test(e)&&(e=e.replace(s,"$1$2")),s=x,(n=g).test(e)){var u=n.exec(e);(n=h).test(u[1])&&(n=v,e=e.replace(n,""))}else if(s.test(e)){t=(u=s.exec(e))[1],(s=p).test(t)&&(o=Q,a=k,(s=w).test(e=t)?e+="e":o.test(e)?(n=v,e=e.replace(n,"")):a.test(e)&&(e+="e"))}if((n=S).test(e)&&(e=(t=(u=n.exec(e))[1])+"i"),(n=E).test(e)&&(t=(u=n.exec(e))[1],r=u[2],(n=h).test(t)&&(e=t+l[r])),(n=L).test(e)&&(t=(u=n.exec(e))[1],r=u[2],(n=h).test(t)&&(e=t+c[r])),s=P,(n=b).test(e))t=(u=n.exec(e))[1],(n=d).test(t)&&(e=t);else if(s.test(e)){t=(u=s.exec(e))[1]+u[2],(s=d).test(t)&&(e=t)}return(n=T).test(e)&&(t=(u=n.exec(e))[1],s=f,o=I,((n=d).test(t)||s.test(t)&&!o.test(t))&&(e=t)),s=d,(n=O).test(e)&&s.test(e)&&(n=v,e=e.replace(n,"")),"y"==i&&(e=i.toLowerCase()+e.substr(1)),e}z.version="2.3.8",z.utils={},z.utils.warn=(t=this,function(e){t.console&&console.warn&&console.warn(e)}),z.utils.asString=function(e){return null==e?"":e.toString()},z.utils.clone=function(e){if(null==e)return e;for(var t=Object.create(null),r=Object.keys(e),i=0;i<r.length;i++){var n=r[i],s=e[n];if(Array.isArray(s))t[n]=s.slice();else{if("string"!=typeof s&&"number"!=typeof s&&"boolean"!=typeof s)throw new TypeError("clone is not deep and does not support nested objects");t[n]=s}}return t},z.FieldRef=function(e,t,r){this.docRef=e,this.fieldName=t,this._stringValue=r},z.FieldRef.joiner="/",z.FieldRef.fromString=function(e){var t=e.indexOf(z.FieldRef.joiner);if(-1===t)throw"malformed field ref string";var r=e.slice(0,t),i=e.slice(t+1);return new z.FieldRef(i,r,e)},z.FieldRef.prototype.toString=function(){return null==this._stringValue&&(this._stringValue=this.fieldName+z.FieldRef.joiner+this.docRef),this._stringValue},z.Set=function(e){if(this.elements=Object.create(null),e){this.length=e.length;for(var t=0;t<this.length;t++)this.elements[e[t]]=!0}else this.length=0},z.Set.complete={intersect:function(e){return e},union:function(e){return e},contains:function(){return!0}},z.Set.empty={intersect:function(){return this},union:function(e){return e},contains:function(){return!1}},z.Set.prototype.contains=function(e){return!!this.elements[e]},z.Set.prototype.intersect=function(e){var t,r,i,n=[];if(e===z.Set.complete)return this;if(e===z.Set.empty)return e;r=this.length<e.length?(t=this,e):(t=e,this),i=Object.keys(t.elements);for(var s=0;s<i.length;s++){var o=i[s];o in r.elements&&n.push(o)}return new z.Set(n)},z.Set.prototype.union=function(e){return e===z.Set.complete?z.Set.complete:e===z.Set.empty?this:new z.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))},z.idf=function(e,t){var r=0;for(var i in e)"_index"!=i&&(r+=Object.keys(e[i]).length);var n=(t-r+.5)/(r+.5);return Math.log(1+Math.abs(n))},z.Token=function(e,t){this.str=e||"",this.metadata=t||{}},z.Token.prototype.toString=function(){return this.str},z.Token.prototype.update=function(e){return this.str=e(this.str,this.metadata),this},z.Token.prototype.clone=function(e){return e=e||function(e){return e},new z.Token(e(this.str,this.metadata),this.metadata)},z.tokenizer=function(e,t){if(null==e||null==e)return[];if(Array.isArray(e))return e.map(function(e){return new z.Token(z.utils.asString(e).toLowerCase(),z.utils.clone(t))});for(var r=e.toString().toLowerCase(),i=r.length,n=[],s=0,o=0;s<=i;s++){var a=s-o;if(r.charAt(s).match(z.tokenizer.separator)||s==i){if(0<a){var u=z.utils.clone(t)||{};u.position=[o,a],u.index=n.length,n.push(new z.Token(r.slice(o,s),u))}o=s+1}}return n},z.tokenizer.separator=/[\s\-]+/,z.Pipeline=function(){this._stack=[]},z.Pipeline.registeredFunctions=Object.create(null),z.Pipeline.registerFunction=function(e,t){t in this.registeredFunctions&&z.utils.warn("Overwriting existing registered function: "+t),e.label=t,z.Pipeline.registeredFunctions[e.label]=e},z.Pipeline.warnIfFunctionNotRegistered=function(e){e.label&&e.label in this.registeredFunctions||z.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},z.Pipeline.load=function(e){var r=new z.Pipeline;return e.forEach(function(e){var t=z.Pipeline.registeredFunctions[e];if(!t)throw new Error("Cannot load unregistered function: "+e);r.add(t)}),r},z.Pipeline.prototype.add=function(){Array.prototype.slice.call(arguments).forEach(function(e){z.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)},this)},z.Pipeline.prototype.after=function(e,t){z.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");r+=1,this._stack.splice(r,0,t)},z.Pipeline.prototype.before=function(e,t){z.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");this._stack.splice(r,0,t)},z.Pipeline.prototype.remove=function(e){var t=this._stack.indexOf(e);-1!=t&&this._stack.splice(t,1)},z.Pipeline.prototype.run=function(e){for(var t=this._stack.length,r=0;r<t;r++){for(var i=this._stack[r],n=[],s=0;s<e.length;s++){var o=i(e[s],s,e);if(null!=o&&""!==o)if(Array.isArray(o))for(var a=0;a<o.length;a++)n.push(o[a]);else n.push(o)}e=n}return e},z.Pipeline.prototype.runString=function(e,t){var r=new z.Token(e,t);return this.run([r]).map(function(e){return e.toString()})},z.Pipeline.prototype.reset=function(){this._stack=[]},z.Pipeline.prototype.toJSON=function(){return this._stack.map(function(e){return z.Pipeline.warnIfFunctionNotRegistered(e),e.label})},z.Vector=function(e){this._magnitude=0,this.elements=e||[]},z.Vector.prototype.positionForIndex=function(e){if(0==this.elements.length)return 0;for(var t=0,r=this.elements.length/2,i=r-t,n=Math.floor(i/2),s=this.elements[2*n];1<i&&(s<e&&(t=n),e<s&&(r=n),s!=e);)i=r-t,n=t+Math.floor(i/2),s=this.elements[2*n];return s==e?2*n:e<s?2*n:s<e?2*(n+1):void 0},z.Vector.prototype.insert=function(e,t){this.upsert(e,t,function(){throw"duplicate index"})},z.Vector.prototype.upsert=function(e,t,r){this._magnitude=0;var i=this.positionForIndex(e);this.elements[i]==e?this.elements[i+1]=r(this.elements[i+1],t):this.elements.splice(i,0,e,t)},z.Vector.prototype.magnitude=function(){if(this._magnitude)return this._magnitude;for(var e=0,t=this.elements.length,r=1;r<t;r+=2){var i=this.elements[r];e+=i*i}return this._magnitude=Math.sqrt(e)},z.Vector.prototype.dot=function(e){for(var t=0,r=this.elements,i=e.elements,n=r.length,s=i.length,o=0,a=0,u=0,l=0;u<n&&l<s;)(o=r[u])<(a=i[l])?u+=2:a<o?l+=2:o==a&&(t+=r[u+1]*i[l+1],u+=2,l+=2);return t},z.Vector.prototype.similarity=function(e){return this.dot(e)/this.magnitude()||0},z.Vector.prototype.toArray=function(){for(var e=new Array(this.elements.length/2),t=1,r=0;t<this.elements.length;t+=2,r++)e[r]=this.elements[t];return e},z.Vector.prototype.toJSON=function(){return this.elements},z.stemmer=(l={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},c={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},e="[aeiouy]",r="[^aeiou][^aeiouy]*",h=new RegExp("^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*"),d=new RegExp("^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*"),f=new RegExp("^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*([aeiouy][aeiou]*)?$"),p=new RegExp("^([^aeiou][^aeiouy]*)?[aeiouy]"),y=/^(.+?)(ss|i)es$/,m=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,x=/^(.+?)(ed|ing)$/,v=/.$/,w=/(at|bl|iz)$/,Q=new RegExp("([^aeiouylsz])\\1$"),k=new RegExp("^"+r+e+"[^aeiouwxy]$"),S=/^(.+?[^aeiou])y$/,E=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,L=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,b=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,P=/^(.+?)(s|t)(ion)$/,T=/^(.+?)e$/,O=/ll$/,I=new RegExp("^"+r+e+"[^aeiouwxy]$"),function(e){return e.update(s)}),z.Pipeline.registerFunction(z.stemmer,"stemmer"),z.generateStopWordFilter=function(e){var t=e.reduce(function(e,t){return e[t]=t,e},{});return function(e){if(e&&t[e.toString()]!==e.toString())return e}},z.stopWordFilter=z.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),z.Pipeline.registerFunction(z.stopWordFilter,"stopWordFilter"),z.trimmer=function(e){return e.update(function(e){return e.replace(/^\W+/,"").replace(/\W+$/,"")})},z.Pipeline.registerFunction(z.trimmer,"trimmer"),z.TokenSet=function(){this.final=!1,this.edges={},this.id=z.TokenSet._nextId,z.TokenSet._nextId+=1},z.TokenSet._nextId=1,z.TokenSet.fromArray=function(e){for(var t=new z.TokenSet.Builder,r=0,i=e.length;r<i;r++)t.insert(e[r]);return t.finish(),t.root},z.TokenSet.fromClause=function(e){return"editDistance"in e?z.TokenSet.fromFuzzyString(e.term,e.editDistance):z.TokenSet.fromString(e.term)},z.TokenSet.fromFuzzyString=function(e,t){for(var r=new z.TokenSet,i=[{node:r,editsRemaining:t,str:e}];i.length;){var n=i.pop();if(0<n.str.length){var s,o=n.str.charAt(0);o in n.node.edges?s=n.node.edges[o]:(s=new z.TokenSet,n.node.edges[o]=s),1==n.str.length&&(s.final=!0),i.push({node:s,editsRemaining:n.editsRemaining,str:n.str.slice(1)})}if(0!=n.editsRemaining){if("*"in n.node.edges)var a=n.node.edges["*"];else{a=new z.TokenSet;n.node.edges["*"]=a}if(0==n.str.length&&(a.final=!0),i.push({node:a,editsRemaining:n.editsRemaining-1,str:n.str}),1<n.str.length&&i.push({node:n.node,editsRemaining:n.editsRemaining-1,str:n.str.slice(1)}),1==n.str.length&&(n.node.final=!0),1<=n.str.length){if("*"in n.node.edges)var u=n.node.edges["*"];else{u=new z.TokenSet;n.node.edges["*"]=u}1==n.str.length&&(u.final=!0),i.push({node:u,editsRemaining:n.editsRemaining-1,str:n.str.slice(1)})}if(1<n.str.length){var l,c=n.str.charAt(0),h=n.str.charAt(1);h in n.node.edges?l=n.node.edges[h]:(l=new z.TokenSet,n.node.edges[h]=l),1==n.str.length&&(l.final=!0),i.push({node:l,editsRemaining:n.editsRemaining-1,str:c+n.str.slice(2)})}}}return r},z.TokenSet.fromString=function(e){for(var t=new z.TokenSet,r=t,i=0,n=e.length;i<n;i++){var s=e[i],o=i==n-1;if("*"==s)(t.edges[s]=t).final=o;else{var a=new z.TokenSet;a.final=o,t.edges[s]=a,t=a}}return r},z.TokenSet.prototype.toArray=function(){for(var e=[],t=[{prefix:"",node:this}];t.length;){var r=t.pop(),i=Object.keys(r.node.edges),n=i.length;r.node.final&&(r.prefix.charAt(0),e.push(r.prefix));for(var s=0;s<n;s++){var o=i[s];t.push({prefix:r.prefix.concat(o),node:r.node.edges[o]})}}return e},z.TokenSet.prototype.toString=function(){if(this._str)return this._str;for(var e=this.final?"1":"0",t=Object.keys(this.edges).sort(),r=t.length,i=0;i<r;i++){var n=t[i];e=e+n+this.edges[n].id}return e},z.TokenSet.prototype.intersect=function(e){for(var t=new z.TokenSet,r=void 0,i=[{qNode:e,output:t,node:this}];i.length;){r=i.pop();for(var n=Object.keys(r.qNode.edges),s=n.length,o=Object.keys(r.node.edges),a=o.length,u=0;u<s;u++)for(var l=n[u],c=0;c<a;c++){var h=o[c];if(h==l||"*"==l){var d=r.node.edges[h],f=r.qNode.edges[l],p=d.final&&f.final,y=void 0;h in r.output.edges?(y=r.output.edges[h]).final=y.final||p:((y=new z.TokenSet).final=p,r.output.edges[h]=y),i.push({qNode:f,output:y,node:d})}}}return t},z.TokenSet.Builder=function(){this.previousWord="",this.root=new z.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}},z.TokenSet.Builder.prototype.insert=function(e){var t,r=0;if(e<this.previousWord)throw new Error("Out of order word insertion");for(var i=0;i<e.length&&i<this.previousWord.length&&e[i]==this.previousWord[i];i++)r++;this.minimize(r),t=0==this.uncheckedNodes.length?this.root:this.uncheckedNodes[this.uncheckedNodes.length-1].child;for(i=r;i<e.length;i++){var n=new z.TokenSet,s=e[i];t.edges[s]=n,this.uncheckedNodes.push({parent:t,char:s,child:n}),t=n}t.final=!0,this.previousWord=e},z.TokenSet.Builder.prototype.finish=function(){this.minimize(0)},z.TokenSet.Builder.prototype.minimize=function(e){for(var t=this.uncheckedNodes.length-1;e<=t;t--){var r=this.uncheckedNodes[t],i=r.child.toString();i in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[i]:(r.child._str=i,this.minimizedNodes[i]=r.child),this.uncheckedNodes.pop()}},z.Index=function(e){this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline},z.Index.prototype.search=function(t){return this.query(function(e){new z.QueryParser(t,e).parse()})},z.Index.prototype.query=function(e){for(var t=new z.Query(this.fields),r=Object.create(null),i=Object.create(null),n=Object.create(null),s=Object.create(null),o=Object.create(null),a=0;a<this.fields.length;a++)i[this.fields[a]]=new z.Vector;e.call(t,t);for(a=0;a<t.clauses.length;a++){var u=t.clauses[a],l=null,c=z.Set.complete;l=u.usePipeline?this.pipeline.runString(u.term,{fields:u.fields}):[u.term];for(var h=0;h<l.length;h++){var d=l[h];u.term=d;var f=z.TokenSet.fromClause(u),p=this.tokenSet.intersect(f).toArray();if(0===p.length&&u.presence===z.Query.presence.REQUIRED){for(var y=0;y<u.fields.length;y++){s[R=u.fields[y]]=z.Set.empty}break}for(var m=0;m<p.length;m++){var g=p[m],x=this.invertedIndex[g],v=x._index;for(y=0;y<u.fields.length;y++){var w=x[R=u.fields[y]],Q=Object.keys(w),k=g+"/"+R,S=new z.Set(Q);if(u.presence==z.Query.presence.REQUIRED&&(c=c.union(S),void 0===s[R]&&(s[R]=z.Set.complete)),u.presence!=z.Query.presence.PROHIBITED){if(i[R].upsert(v,u.boost,function(e,t){return e+t}),!n[k]){for(var E=0;E<Q.length;E++){var L,b=Q[E],P=new z.FieldRef(b,R),T=w[b];void 0===(L=r[P])?r[P]=new z.MatchData(g,R,T):L.add(g,R,T)}n[k]=!0}}else void 0===o[R]&&(o[R]=z.Set.empty),o[R]=o[R].union(S)}}}if(u.presence===z.Query.presence.REQUIRED)for(y=0;y<u.fields.length;y++){s[R=u.fields[y]]=s[R].intersect(c)}}var O=z.Set.complete,I=z.Set.empty;for(a=0;a<this.fields.length;a++){var R;s[R=this.fields[a]]&&(O=O.intersect(s[R])),o[R]&&(I=I.union(o[R]))}var F=Object.keys(r),C=[],N=Object.create(null);if(t.isNegated()){F=Object.keys(this.fieldVectors);for(a=0;a<F.length;a++){P=F[a];var j=z.FieldRef.fromString(P);r[P]=new z.MatchData}}for(a=0;a<F.length;a++){var _=(j=z.FieldRef.fromString(F[a])).docRef;if(O.contains(_)&&!I.contains(_)){var D,A=this.fieldVectors[j],B=i[j.fieldName].similarity(A);if(void 0!==(D=N[_]))D.score+=B,D.matchData.combine(r[j]);else{var V={ref:_,score:B,matchData:r[j]};N[_]=V,C.push(V)}}}return C.sort(function(e,t){return t.score-e.score})},z.Index.prototype.toJSON=function(){var e=Object.keys(this.invertedIndex).sort().map(function(e){return[e,this.invertedIndex[e]]},this),t=Object.keys(this.fieldVectors).map(function(e){return[e,this.fieldVectors[e].toJSON()]},this);return{version:z.version,fields:this.fields,fieldVectors:t,invertedIndex:e,pipeline:this.pipeline.toJSON()}},z.Index.load=function(e){var t={},r={},i=e.fieldVectors,n=Object.create(null),s=e.invertedIndex,o=new z.TokenSet.Builder,a=z.Pipeline.load(e.pipeline);e.version!=z.version&&z.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+z.version+"' does not match serialized index '"+e.version+"'");for(var u=0;u<i.length;u++){var l=(h=i[u])[0],c=h[1];r[l]=new z.Vector(c)}for(u=0;u<s.length;u++){var h,d=(h=s[u])[0],f=h[1];o.insert(d),n[d]=f}return o.finish(),t.fields=e.fields,t.fieldVectors=r,t.invertedIndex=n,t.tokenSet=o.root,t.pipeline=a,new z.Index(t)},z.Builder=function(){this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=z.tokenizer,this.pipeline=new z.Pipeline,this.searchPipeline=new z.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]},z.Builder.prototype.ref=function(e){this._ref=e},z.Builder.prototype.field=function(e,t){if(/\//.test(e))throw new RangeError("Field '"+e+"' contains illegal character '/'");this._fields[e]=t||{}},z.Builder.prototype.b=function(e){this._b=e<0?0:1<e?1:e},z.Builder.prototype.k1=function(e){this._k1=e},z.Builder.prototype.add=function(e,t){var r=e[this._ref],i=Object.keys(this._fields);this._documents[r]=t||{},this.documentCount+=1;for(var n=0;n<i.length;n++){var s=i[n],o=this._fields[s].extractor,a=o?o(e):e[s],u=this.tokenizer(a,{fields:[s]}),l=this.pipeline.run(u),c=new z.FieldRef(r,s),h=Object.create(null);this.fieldTermFrequencies[c]=h,this.fieldLengths[c]=0,this.fieldLengths[c]+=l.length;for(var d=0;d<l.length;d++){var f=l[d];if(null==h[f]&&(h[f]=0),h[f]+=1,null==this.invertedIndex[f]){var p=Object.create(null);p._index=this.termIndex,this.termIndex+=1;for(var y=0;y<i.length;y++)p[i[y]]=Object.create(null);this.invertedIndex[f]=p}null==this.invertedIndex[f][s][r]&&(this.invertedIndex[f][s][r]=Object.create(null));for(var m=0;m<this.metadataWhitelist.length;m++){var g=this.metadataWhitelist[m],x=f.metadata[g];null==this.invertedIndex[f][s][r][g]&&(this.invertedIndex[f][s][r][g]=[]),this.invertedIndex[f][s][r][g].push(x)}}}},z.Builder.prototype.calculateAverageFieldLengths=function(){for(var e=Object.keys(this.fieldLengths),t=e.length,r={},i={},n=0;n<t;n++){var s=z.FieldRef.fromString(e[n]),o=s.fieldName;i[o]||(i[o]=0),i[o]+=1,r[o]||(r[o]=0),r[o]+=this.fieldLengths[s]}var a=Object.keys(this._fields);for(n=0;n<a.length;n++){var u=a[n];r[u]=r[u]/i[u]}this.averageFieldLength=r},z.Builder.prototype.createFieldVectors=function(){for(var e={},t=Object.keys(this.fieldTermFrequencies),r=t.length,i=Object.create(null),n=0;n<r;n++){for(var s=z.FieldRef.fromString(t[n]),o=s.fieldName,a=this.fieldLengths[s],u=new z.Vector,l=this.fieldTermFrequencies[s],c=Object.keys(l),h=c.length,d=this._fields[o].boost||1,f=this._documents[s.docRef].boost||1,p=0;p<h;p++){var y,m,g,x=c[p],v=l[x],w=this.invertedIndex[x]._index;void 0===i[x]?(y=z.idf(this.invertedIndex[x],this.documentCount),i[x]=y):y=i[x],m=y*((this._k1+1)*v)/(this._k1*(1-this._b+this._b*(a/this.averageFieldLength[o]))+v),m*=d,m*=f,g=Math.round(1e3*m)/1e3,u.insert(w,g)}e[s]=u}this.fieldVectors=e},z.Builder.prototype.createTokenSet=function(){this.tokenSet=z.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())},z.Builder.prototype.build=function(){return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new z.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})},z.Builder.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},z.MatchData=function(e,t,r){for(var i=Object.create(null),n=Object.keys(r||{}),s=0;s<n.length;s++){var o=n[s];i[o]=r[o].slice()}this.metadata=Object.create(null),void 0!==e&&(this.metadata[e]=Object.create(null),this.metadata[e][t]=i)},z.MatchData.prototype.combine=function(e){for(var t=Object.keys(e.metadata),r=0;r<t.length;r++){var i=t[r],n=Object.keys(e.metadata[i]);null==this.metadata[i]&&(this.metadata[i]=Object.create(null));for(var s=0;s<n.length;s++){var o=n[s],a=Object.keys(e.metadata[i][o]);null==this.metadata[i][o]&&(this.metadata[i][o]=Object.create(null));for(var u=0;u<a.length;u++){var l=a[u];null==this.metadata[i][o][l]?this.metadata[i][o][l]=e.metadata[i][o][l]:this.metadata[i][o][l]=this.metadata[i][o][l].concat(e.metadata[i][o][l])}}}},z.MatchData.prototype.add=function(e,t,r){if(!(e in this.metadata))return this.metadata[e]=Object.create(null),void(this.metadata[e][t]=r);if(t in this.metadata[e])for(var i=Object.keys(r),n=0;n<i.length;n++){var s=i[n];s in this.metadata[e][t]?this.metadata[e][t][s]=this.metadata[e][t][s].concat(r[s]):this.metadata[e][t][s]=r[s]}else this.metadata[e][t]=r},z.Query=function(e){this.clauses=[],this.allFields=e},z.Query.wildcard=new String("*"),z.Query.wildcard.NONE=0,z.Query.wildcard.LEADING=1,z.Query.wildcard.TRAILING=2,z.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},z.Query.prototype.clause=function(e){return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=z.Query.wildcard.NONE),e.wildcard&z.Query.wildcard.LEADING&&e.term.charAt(0)!=z.Query.wildcard&&(e.term="*"+e.term),e.wildcard&z.Query.wildcard.TRAILING&&e.term.slice(-1)!=z.Query.wildcard&&(e.term=e.term+"*"),"presence"in e||(e.presence=z.Query.presence.OPTIONAL),this.clauses.push(e),this},z.Query.prototype.isNegated=function(){for(var e=0;e<this.clauses.length;e++)if(this.clauses[e].presence!=z.Query.presence.PROHIBITED)return!1;return!0},z.Query.prototype.term=function(e,t){if(Array.isArray(e))return e.forEach(function(e){this.term(e,z.utils.clone(t))},this),this;var r=t||{};return r.term=e.toString(),this.clause(r),this},z.QueryParseError=function(e,t,r){this.name="QueryParseError",this.message=e,this.start=t,this.end=r},z.QueryParseError.prototype=new Error,z.QueryLexer=function(e){this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]},z.QueryLexer.prototype.run=function(){for(var e=z.QueryLexer.lexText;e;)e=e(this)},z.QueryLexer.prototype.sliceString=function(){for(var e=[],t=this.start,r=this.pos,i=0;i<this.escapeCharPositions.length;i++)r=this.escapeCharPositions[i],e.push(this.str.slice(t,r)),t=r+1;return e.push(this.str.slice(t,this.pos)),this.escapeCharPositions.length=0,e.join("")},z.QueryLexer.prototype.emit=function(e){this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos},z.QueryLexer.prototype.escapeCharacter=function(){this.escapeCharPositions.push(this.pos-1),this.pos+=1},z.QueryLexer.prototype.next=function(){if(this.pos>=this.length)return z.QueryLexer.EOS;var e=this.str.charAt(this.pos);return this.pos+=1,e},z.QueryLexer.prototype.width=function(){return this.pos-this.start},z.QueryLexer.prototype.ignore=function(){this.start==this.pos&&(this.pos+=1),this.start=this.pos},z.QueryLexer.prototype.backup=function(){--this.pos},z.QueryLexer.prototype.acceptDigitRun=function(){for(var e,t;47<(t=(e=this.next()).charCodeAt(0))&&t<58;);e!=z.QueryLexer.EOS&&this.backup()},z.QueryLexer.prototype.more=function(){return this.pos<this.length},z.QueryLexer.EOS="EOS",z.QueryLexer.FIELD="FIELD",z.QueryLexer.TERM="TERM",z.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",z.QueryLexer.BOOST="BOOST",z.QueryLexer.PRESENCE="PRESENCE",z.QueryLexer.lexField=function(e){return e.backup(),e.emit(z.QueryLexer.FIELD),e.ignore(),z.QueryLexer.lexText},z.QueryLexer.lexTerm=function(e){if(1<e.width()&&(e.backup(),e.emit(z.QueryLexer.TERM)),e.ignore(),e.more())return z.QueryLexer.lexText},z.QueryLexer.lexEditDistance=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(z.QueryLexer.EDIT_DISTANCE),z.QueryLexer.lexText},z.QueryLexer.lexBoost=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(z.QueryLexer.BOOST),z.QueryLexer.lexText},z.QueryLexer.lexEOS=function(e){0<e.width()&&e.emit(z.QueryLexer.TERM)},z.QueryLexer.termSeparator=z.tokenizer.separator,z.QueryLexer.lexText=function(e){for(;;){var t=e.next();if(t==z.QueryLexer.EOS)return z.QueryLexer.lexEOS;if(92!=t.charCodeAt(0)){if(":"==t)return z.QueryLexer.lexField;if("~"==t)return e.backup(),0<e.width()&&e.emit(z.QueryLexer.TERM),z.QueryLexer.lexEditDistance;if("^"==t)return e.backup(),0<e.width()&&e.emit(z.QueryLexer.TERM),z.QueryLexer.lexBoost;if("+"==t&&1===e.width())return e.emit(z.QueryLexer.PRESENCE),z.QueryLexer.lexText;if("-"==t&&1===e.width())return e.emit(z.QueryLexer.PRESENCE),z.QueryLexer.lexText;if(t.match(z.QueryLexer.termSeparator))return z.QueryLexer.lexTerm}else e.escapeCharacter()}},z.QueryParser=function(e,t){this.lexer=new z.QueryLexer(e),this.query=t,this.currentClause={},this.lexemeIdx=0},z.QueryParser.prototype.parse=function(){this.lexer.run(),this.lexemes=this.lexer.lexemes;for(var e=z.QueryParser.parseClause;e;)e=e(this);return this.query},z.QueryParser.prototype.peekLexeme=function(){return this.lexemes[this.lexemeIdx]},z.QueryParser.prototype.consumeLexeme=function(){var e=this.peekLexeme();return this.lexemeIdx+=1,e},z.QueryParser.prototype.nextClause=function(){var e=this.currentClause;this.query.clause(e),this.currentClause={}},z.QueryParser.parseClause=function(e){var t=e.peekLexeme();if(null!=t)switch(t.type){case z.QueryLexer.PRESENCE:return z.QueryParser.parsePresence;case z.QueryLexer.FIELD:return z.QueryParser.parseField;case z.QueryLexer.TERM:return z.QueryParser.parseTerm;default:var r="expected either a field or a term, found "+t.type;throw 1<=t.str.length&&(r+=" with value '"+t.str+"'"),new z.QueryParseError(r,t.start,t.end)}},z.QueryParser.parsePresence=function(e){var t=e.consumeLexeme();if(null!=t){switch(t.str){case"-":e.currentClause.presence=z.Query.presence.PROHIBITED;break;case"+":e.currentClause.presence=z.Query.presence.REQUIRED;break;default:var r="unrecognised presence operator'"+t.str+"'";throw new z.QueryParseError(r,t.start,t.end)}var i=e.peekLexeme();if(null==i){r="expecting term or field, found nothing";throw new z.QueryParseError(r,t.start,t.end)}switch(i.type){case z.QueryLexer.FIELD:return z.QueryParser.parseField;case z.QueryLexer.TERM:return z.QueryParser.parseTerm;default:r="expecting term or field, found '"+i.type+"'";throw new z.QueryParseError(r,i.start,i.end)}}},z.QueryParser.parseField=function(e){var t=e.consumeLexeme();if(null!=t){if(-1==e.query.allFields.indexOf(t.str)){var r=e.query.allFields.map(function(e){return"'"+e+"'"}).join(", "),i="unrecognised field '"+t.str+"', possible fields: "+r;throw new z.QueryParseError(i,t.start,t.end)}e.currentClause.fields=[t.str];var n=e.peekLexeme();if(null==n){i="expecting term, found nothing";throw new z.QueryParseError(i,t.start,t.end)}switch(n.type){case z.QueryLexer.TERM:return z.QueryParser.parseTerm;default:i="expecting term, found '"+n.type+"'";throw new z.QueryParseError(i,n.start,n.end)}}},z.QueryParser.parseTerm=function(e){var t=e.consumeLexeme();if(null!=t){e.currentClause.term=t.str.toLowerCase(),-1!=t.str.indexOf("*")&&(e.currentClause.usePipeline=!1);var r=e.peekLexeme();if(null!=r)switch(r.type){case z.QueryLexer.TERM:return e.nextClause(),z.QueryParser.parseTerm;case z.QueryLexer.FIELD:return e.nextClause(),z.QueryParser.parseField;case z.QueryLexer.EDIT_DISTANCE:return z.QueryParser.parseEditDistance;case z.QueryLexer.BOOST:return z.QueryParser.parseBoost;case z.QueryLexer.PRESENCE:return e.nextClause(),z.QueryParser.parsePresence;default:var i="Unexpected lexeme type '"+r.type+"'";throw new z.QueryParseError(i,r.start,r.end)}else e.nextClause()}},z.QueryParser.parseEditDistance=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var i="edit distance must be numeric";throw new z.QueryParseError(i,t.start,t.end)}e.currentClause.editDistance=r;var n=e.peekLexeme();if(null!=n)switch(n.type){case z.QueryLexer.TERM:return e.nextClause(),z.QueryParser.parseTerm;case z.QueryLexer.FIELD:return e.nextClause(),z.QueryParser.parseField;case z.QueryLexer.EDIT_DISTANCE:return z.QueryParser.parseEditDistance;case z.QueryLexer.BOOST:return z.QueryParser.parseBoost;case z.QueryLexer.PRESENCE:return e.nextClause(),z.QueryParser.parsePresence;default:i="Unexpected lexeme type '"+n.type+"'";throw new z.QueryParseError(i,n.start,n.end)}else e.nextClause()}},z.QueryParser.parseBoost=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var i="boost must be numeric";throw new z.QueryParseError(i,t.start,t.end)}e.currentClause.boost=r;var n=e.peekLexeme();if(null!=n)switch(n.type){case z.QueryLexer.TERM:return e.nextClause(),z.QueryParser.parseTerm;case z.QueryLexer.FIELD:return e.nextClause(),z.QueryParser.parseField;case z.QueryLexer.EDIT_DISTANCE:return z.QueryParser.parseEditDistance;case z.QueryLexer.BOOST:return z.QueryParser.parseBoost;case z.QueryLexer.PRESENCE:return e.nextClause(),z.QueryParser.parsePresence;default:i="Unexpected lexeme type '"+n.type+"'";throw new z.QueryParseError(i,n.start,n.end)}else e.nextClause()}},i=this,n=function(){return z},"function"==typeof define&&define.amd?define(n):"object"==typeof exports?module.exports=n():i.lunr=n()}();;const idx=lunr(function(){this.field('id')
this.field('link')
this.field('title')
this.field('body')
this.add({"id":"0","link":"https://wiki.phala.network/en-us/docs/","title":"Overview","body":"[Lack of Confidentiality in Blockchains Blockchain is a kind of distributed ledger which records the transactions in an ever-growing list of blocks. Its nature of trust comes from the fact that the execution of every transaction can be verified by any user of the blockchain. Existing blockchains, such as BTC and ETH, live up to this promise in an intuitive way: they make everything public, including the transactions and the internal states of smart contracts. This brings the problem: confidential data cannot be processed by these blockchains. Phala Network tries to tackle this challenging problem. It seeks to provide strong guarantee of confidentiality without sacrificing cross-contract interoperability, which means the confidential contracts on Phala Network can interact with other confidential contracts freely. Further, as a Polkadot parachain, Phala Network enables cross-chain interoperability of smart contracts to confidentially operate assets on another blockchain. What is a Confidential Contract 1 2 3 4 5 6 7 8 9 10 11 12 pubstruct HelloWorld{counter: u32,}fn handle_command(&amp;mutself,origin: &amp;chain::AccountId,txref: &amp;TxRef,cmd: Command)-&gt; TransactionStatus{matchcmd{Command::Increment{value}=&gt;{self.counter+=value;TransactionStatus::Ok},}} Note: Some boilerplate code was removed for simplicity A confidential contract is nothing more than an ordinary smart contract, but with confidentiality. The above code is a snippet of a sample contract where it stores a counter and anyone can increment it but only authorized user can read it. The Phala contracts are written in Rust, a programming language that can do anything on the blockchain. You can make full use of your favorite package manager Cargo and libraries at crates.io. So far, we have a HelloWorld contract with a counter, but it's only the first half! Now you may wonder what is the difference between confidential contracts and other smart contracts. The second half revels the secret. 1 2 3 4 5 6 7 8 9 10 fn handle_query(&amp;mutself,origin: Option&lt;&amp;chain::AccountId&gt;,req: Request)-&gt; Response{matchreq{Request::GetCount=&gt;{iforigin!=Some(ROOT_ACCOUNT){Response::Error(Error::NotAuthorized)}else{Response::GetCount{count: self.counter})}}} Unlike traditional smart contracts, the states in a confidential contract is not accessible outside the contract in any way, unless via &quot;queries&quot;, by which you can define who has the permission to access which part of the data. In this example, we only allow a special account ROOT_ACCOUNT to read the counter, otherwise the requester will get a NotAuthorized error. In fact, in addition to the contract states, the inputs and outputs of the contract are also end-to-end encrypted. The contract developer can design how the data can be accessed in a fully flexible way. **Side notes: Private variable are not private on Ethereum. ** Though you can define variables with &quot;private&quot; attribute, the data is still public on the blockchain. According to the solidity doc: Everything that is inside a contract is visible to all observers external to the blockchain. Making something private only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain. The Root of Trust: TEE Phala provides confidentiality guarantee based on trusted hardwares, or Trusted Execution Environment, which means your code and data are safe even if your operating system is compromised. A contract executing in the TEE is just like the priest in the confessional room: You know who he is, you can tell he what you want and he will reply, but only God knows what's going on there. The most important thing is: All your secrets are safe. Phala adopts one of the most popular implementations of TEE, i.e., Intel SGX. Intel SGX introduces a small set of instructions to encrypt the data in memory, and attackers cannot decrypt it without cracking the CPU and extracting the secret key in it. Unlike existing blockchains in which all contract states are public on chain, the states of confidential contracts are encrypted and sealed in SGX. Phala Network in Detail Phala Network is consisted of three components: phala-nodes which make up of Phala blockchain, pRuntime and phost. Among them, only pRuntime lives in TEE. Although attackers cannot peek into TEE, they can trick the contracts in TEE by forging transactions or replaying/reordering valid transactions. It it important to ensure that confidential contracts only accept valid transactions and process transactions in an expected order. That's why we introduce Phala blockchain and phost. Phala blockchain serves as a canonical source of valid transactions. Only submitted transactions can be accepted by pRuntime, and they will be processed in the same order as on blockchain. We implement a light validaton client in pRuntime so it is able to determine whether valid transactions are accepted in expected order. Also a key rotation mechanism will be introduced to prevent the replay of historical transactions. The great thing is that pRuntime hides all these complicated implementation details from you so you can just implement confidential contracts like developing ordinary programs. phost works as the bridge between Phala blockchain and pRuntime. It ensures that all the transactions on blockchain are faithfully forwarded to pRuntime and all the TEE instances are running unmodified version of pRuntime.]".toLowerCase(),});this.add({"id":"1","link":"https://wiki.phala.network/en-us/docs/run-a-local-development-network/","title":"Run a Local Development Network","body":"[Basic understanding of Linux shell and compiling is necessary to follow this tutorial. Overview In this tutorial, we are going to set up a &quot;Hello World&quot; development environment. We are going to deploy a full stack of the core blockchain and connect the Web UI to the blockchain. By the end of the tutorial, you will be able to: Send confidential transactions Get a ready-to-hack version of Phala Network for building your own confidential Dapps A full Phala Network stack has three components plus a Web UI. The core components are at Phala-Network/phala-blockchain: phala-node: The Substrate blockchain node pRuntime: The TEE runtime. Contracts runs in pRuntime phost: The Substrate-TEE bridge relayer. Connects the blockchain and pRuntime The Web UI is at Phala-Network/apps-ng. The Web UI needs to connect to both the blockchain and the pRuntime in order to send transaction and queries. Environment The development environment of Phala Network requires Linux, because it relies on Linux Intel SGX SDK. Virtual machines should generally work. Phala Network doesn't work on Windows or macOS natively (sorry, Mac lovers), but we haven't tested WLS yet. Please let us know if you are the first to run it on WLS successfully! In this tutorial we assume the operating system is Ubuntu 18.04. Though not tested yet, it should work with Ubuntu 20.04 out-of-box. Other Linux distributions should also work, but the instructions may vary. It's required to have at least 4 cores and 8GB ram to build the project including the core blockchain and the Web UI. Less than 4GB ram may fail to build the Web UI. Follow the commands below to prepare the environment. Some can be skipped if already installed. Install the system level dependencies 1 2 sudo apt update sudo apt install -y build-essential ocaml ocamlbuild automake autoconf libtool wget python libssl-dev git cmake perl pkg-config curl llvm-10 clang-10 libclang-10-dev Notes on LLVM: We require at least LLVM-9, but higher versions are also supported. Older version like LLVM 6.0 breaks the core blockchain compilation. Install Rust. Please choose the default toolchain 1 2 curl https://sh.rustup.rs -sSf | sh source ~/.cargo/env Install Intel SGX SDK 1 2 3 4 wget https://download.01.org/intel-sgx/sgx-linux/2.11/distro/ubuntu18.04-server/sgx_linux_x64_sdk_2.11.100.2.bin chmod +x ./sgx_linux_x64_sdk_2.11.100.2.bin echo -e &#39;no\n/opt/intel&#39; | sudo ./sgx_linux_x64_sdk_2.11.100.2.bin source /opt/intel/sgxsdk/environment You can add source /opt/sgxsdk/environment to your ~/.bashrc (or ~/.zshrc depends on which shell you're using). Install Node.js (&gt;= v12) &amp; yarn 2 1 2 3 curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash - sudo apt-get install -y nodejs sudo npm install -g yarn You can test the installation by running the following commands. The output should match the sample outputs, or with a slightly higher version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 rustup --version # rustup 1.22.1 (b01adbbc3 2020-07-08) cargo --version # cargo 1.46.0 (149022b1d 2020-07-17) echo $SGX_SDK # /opt/intel/sgxsdk # LLVM-9 or higher versions are fine llvm-ar-10 --version # LLVM (http://llvm.org/): # LLVM version 10.0.0 node --version # v12.16.3 yarn --version # 2.1.1 Finally let's clone the code and run the initialization script to update the rust toolchain. Please note that the entire tutorial is on the helloworld branch for both the blockchain and the Web UI repo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Clone the core blockchain repo git clone --branch helloworld https://github.com/Phala-Network/phala-blockchain.git # Clone the Web UI repo git clone --branch helloworld https://github.com/Phala-Network/apps-ng.git # Run the init script to update rust toolchain and git submodule cd phala-blockchain/ git submodule update --init ./scripts/init.sh cd .. # Update the git submodule cd apps-ng/ git submodule update --init Build the core blockchain Now we already have the both repos phala-blockchain and apps-ng in the working directory. Let's start to build the the core blockchain first. 1 2 3 4 5 6 7 # Build the core blockchain cd phala-blockchain/ cargo build --release # Build pRuntime (TEE Enclave) cd ./pruntime/ SGX_MODE=SW make The compilation takes from 20 mins to 60 mins depending on your internet connection and CPU performance. After building, you will get the three binary files: ./target/release/phala-node: The Substrate node ./target/release/phost: The Substrate-to-TEE bridge relayer ./pruntime/bin/app: The TEE worker Notes on SGX_MODE The SGX SDK supports software simulation mode and hardware mode. SGX_MODE=SW enables the simulation mode. The software mode is for easy development, where the hardware enclave is not required. You can even run it on a virtual machine or a computer with an AMD cpu. However, only the hardware mode can guarantee the security and the confidentiality of the trusted execution. To enable the hardware mode, you have to install Intel SGX DCAP Driver and the platform software shipped with the driver, and pass SGX_MODE=HW to the toolchain. The three core blockchain components work together to bring the full functionalities. Among them, phala-node and pruntime should be launched first, and phost follows: 1 2 3 4 5 6 7 8 9 # In terminal window 1: phala-node ./target/release/phala-node --dev # In terminal window 2: pruntime cd pruntime/bin ./app # In terminal window 3: phost ./target/release/phost --dev (Core components running and producing logs) Once they are launched successfully, they should output logs as shown in the GIF above. Notice that we pass the --dev flag to phala-node and phost to indicate we are in the development network. The three core blockchain components are connected via TCP (WebSocket and HTTP). Please make sure your system have the TCP ports not occupied with other programs. By default they use the following ports: phala-node 9944: Substrate WebSocket RPC port 30333: Substrate P2P network port pruntime 8000: HTTP Restful RPC port phost doesn't listen to any ports but connect to phala-node's WebSocket port and pruntime's HTTP RPC port. You can safely shutdown the three program by Ctrl + C. phala-node saves the blockchain database on your disk. So if the blockchain gets messed up, you may want to reset it by: 1 ./target/release/phala-node purge-chain --dev Build the Web UI The Web UI frontend is developed with node.js, yarn and react. It's easy to build and launch the frontend. 1 2 3 cd apps-ng yarn yarn dev It may take a few minutes to download the dependencies and build the frontend. By default the page is served at http://localhost:3000. So make sure the port 3000 is available. Then it should produce some logs like below: ready - started server on http://localhost:3000 &gt; Using &quot;webpackDevMiddleware&quot; config function defined in default. &gt; Using external babel configuration event - compiled successfully event - build page: /[...slug] event - build page: / event - compiled successfully (Web UI landing page) The Web UI connects to both phala-node and pruntime by their default RPC endpoints. If everything is configured correctly, you will see the wallet unlock screen in the landing page as shown above. You should be able to select the well-known development accounts (Alice, Bob, etc) in the drop box. Notes for Remote Access In a case where you run your blockchain and WEB UI on your REMOTE_SERVER and try to access them elsewhere, you can forward the ports with ssh command. For example, 1 ssh -N -f USER@REMOTE_SERVER -L 3000:localhost:3000 -L 9944:localhost:9944 -L 8000:localhost:8000 This forwards all the necessary ports: 3000: HTTP port of Web UI 9944: Substrate WebSocket RPC port of phala-node 8000: HTTP Restful RPC port of pruntime and you can visit the Web UI at http://localhost:3000. Send some secret tokens In the last two sections, we have built and launched phala-node, pruntime, and phost in development mode, and connect the Web UI to the development network. Now we are ready to try the secret wallet feature in Phala Network! Let's select Alice and unlock the wallet. Alice is a built-in test account with 10,000 PHA on the blockchain. This PHA token is the native token. It's transparent on-chain like a typical Substrate blockchain, managed by Balances pallet. (Secret wallet dapp) However, the &quot;secret assets&quot; wallet below is very different. Secret assets are stored in confidential contracts inside TEE enclaves. Like what the name says, the secret assets are private and invisible on the blockchain. Click &quot;Convert to Secret PHA&quot; button to transfer PHA to Secret PHA. You will see your PHA balance reduced first, and after around ten seconds, the Secret PHA balance will increase by the same amount, except some transaction fee. What just happend? You created a Substrate transaction to send some funds to the Phala pallet. The funds are stored in the pallet, and it triggered a confidential transaction to issue the same amount of the token in the secret wallet in TEE enclaves. It takes ~6s to include a Substrate transaction in the blockchain, and then another 6s to finalize the block. Once the transaction is finalized, it triggers a &quot;TransferToTee&quot; event, relayed to pruntime via the relayer, and the confidential contract increases the balance. Finally the Web UI queries the confidential contract to get the updated balance. There are plenty of things you can play with the secret wallet: convert the secret assets back to on-chain assets; transfer secret assets just like ordinary assets on every Substrate blockchain; and even issue or destroy your own secret tokens All the above functions are made by confidential transaction. Nobody can see the content of the transaction because the body is encrypted. By clicking &quot;Polkadot UI&quot; button in the navigation bar, it will bring you to the polkadot.js apps you are familiar with. After sending an encrypted transaction by clicking the &quot;Secret Transfer&quot; button, you can find the encrypted transaction wrapped by phalaModel.pushCommand extrinsic from the block explorer as shown below. (An encrypted confidential transaction on a blockchain explorer) Conclusion Congratulations! Finally, you have followed the tutorial to: Prepare a ready-to-hack development environment Download, build, and started a full stack development mode Phala Network Connect to the network via the Web UI and try the secret wallet dapp Now you are familiar with building and running a development network. Hold tight! In the next chapter, we are going to build the first confidential contract together! Submit your work This tutorial is a part of Polkadot &quot;Hello World&quot; virtual hackathon challenge at gitcoin.co. In order to win the task, please do the followings: Take screenshots of the terminal window with the running core blockchain (phala-node, pruntime, and phost) Take a screenshot of your user-issued secret token Send the screenshot and share your feeling on Twitter Join our Discord server and submit the the link to your tweet]".toLowerCase(),});this.add({"id":"2","link":"https://wiki.phala.network/en-us/docs/your-first-confidential-contract/","title":"Hello World: your first confidential contract","body":"[Basic understanding of Rust language programming and smart contract development knowledge is necessary to follow this tutorial. Overview In this tutorial, we are going to continue on the development environment we have set up in the previous chapter, and explore how a confidential smart contract is made. By the end of this tutorial, you will: Learn how to develop a confidential contract Interact with the contract from the Web UI Build your own confidential contract For a high-level overview of Phala Network, please check the previous chapters. Environment and Build Please set up a development environment by following the previous chapter Run a Local Development Network. Make sure you are at the helloworld branch on both phala-blockchain and apps-ng repo. Walk-through Contract The HelloWorld contract commit is available at here. HelloWorld contract stores a counter which can be incremented by anyone, but only authorized user can read it. The typical model of the confidential contracts in Phala Network is consisted of the following three components which we will discuss in detail. States Commands Queries The States of a contract is described by certain variables. In this case, we define a 32-bit unsigned variable as the counter, while you are free to use variables of any types in your contracts. 1 2 3 pubstruct HelloWorld{counter: u32,} There are two kinds of operations which can be used to interact with confidential contracts: Commands and Queries. The most significant difference between them is whether or not they change the states of the contracts, and we explain them separately. The Commands are supposed to change the states of contracts. They are also called Transactions, and they are just like the transactions on traditional smart contract blockchains like Ethereum: they must be sent to the blockchain first before their executions. In our HelloWorld contract, we define a Increment command which changes the value of counter. 1 2 3 4 5 6 pubenum Command{/// Increments the counter in the contract by some number Increment{value: u32,},} It is worth noting that you can define more than one commands for a contract. For example, we can add a Decrement command to decrease the counter as follow. 1 2 3 4 5 6 7 8 9 10 pubenum Command{/// Increments the counter in the contract by some number Increment{value: u32,},/// Decrements the counter in the contract by some number Decrement{value: u32,},} All the commands are processed by the handle_command method which must be implemented. In this case, we allow any user to use this command, so we just increase the counter without checking the _origin. 1 2 3 4 5 6 7 8 9 10 11 fn handle_command(&amp;mutself,_origin: &amp;chain::AccountId,_txref: &amp;TxRef,cmd: Command)-&gt; TransactionStatus{matchcmd{// Handle the `Increment` command with one parameter Command::Increment{value}=&gt;{// Simply increment the counter by some value. self.counter+=value;// Returns TransactionStatus::Ok to indicate a successful transaction TransactionStatus::Ok},}} Opposed to commands, Queries shall not change the states of contacts. Queries are one of the innovations of Phala Network. They are designed to allow a quick examination of the states of contracts. To define a query, you need to define both the Request and the according Response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pubenum Request{/// Ask for the value of the counter GetCount,}/// Query responses. pubenum Response{/// Returns the value of the counter GetCount{count: u32,},/// Something wrong happened Error(Error)} handle_query method is supposed to handle all the queries. Unlike commands, Queries go directly to the contracts without the necessity to be sent to the blockchain. In confidential contracts queries are usually required to be signed to indicate the identities of the requesters. Therefore queries can be responded conditionally, which gives the developer great flexible control over the data in confidential contracts. The identity of the requester can be accessed from origin, the second argument of handle_query. We are going to cover more about origin later in this tutorial, but it also supports anonymous queries where origin is None as shown below. The GetCount query simply returns the current value of the counter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn handle_query(&amp;mutself,_origin: Option&lt;&amp;chain::AccountId&gt;,req: Request)-&gt; Response{letinner=||-&gt; Result&lt;Response,Error&gt;{matchreq{// Handle the `GetCount` request. Request::GetCount=&gt;{// Respond with the counter in the contract states. Ok(Response::GetCount{count: self.counter})},}};matchinner(){Err(error)=&gt;Response::Error(error),Ok(resp)=&gt;resp}} Unlike Ethereum, queries in confidential contracts are capable to carry arbitrary computation. So we recommend to introduce an authority check here to avoid potential Denial-of-Service attack with a huge amount of query requests. Frontend Web UI commit: https://github.com/Phala-Network/apps-ng/commit/4a806c8e49edb8f12bd5ed54d1700edf81a6af56 Interact with the contract: how to send command and queries. Implement a secret notebook After a general understanding of the model of confidential contracts, let's make something practical and implement a contract which can store the secret note of each visitor. In this contract, we allow any user to store one note, and only the user himself is allowed to read his note. The SecretNote contract commit is available at https://github.com/Phala-Network/phala-blockchain/commit/d91f94c9ed21290b7353991899f7a6da18cfab61 (CHANGE THIS). We thank Laurent for his implementation of this contract. Contract We use a map to store the users with their notes, and provide two interface SetNote and GetNote for them to operate their notes. We frist define the contract state structure struct SecretNote, with a map notes to store a mapping from the account to the notes. In Phala contracts, an account can be represented by an AccountIdWrapper. 1 2 3 pubstruct SecretNote{notes: BTreeMap&lt;AccountIdWrapper,String&gt;,} In Rust's std collection library, there are two map implementations: HashMap and BTreeMap. Since our AccountIdWrapper does not derive Hash needed by HashMap, we use BTreeMap to store the mapping between user accounts and their notes. Here we recall the difference between commands and queries. In SecretNote, SetNote changes the states, so it is a command, and GetNote is a query. For each user, we only keep the latest note. So in SetNote, we call the insert to add a note if no previous one exists or directly overwrite the existing one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pubenum Command{/// Set the note for current user SetNote{note: String,},}implcontracts::Contract&lt;Command,Request,Response&gt;forSecretNote{fn handle_command(&amp;mutself,origin: &amp;chain::AccountId,_txref: &amp;TxRef,cmd: Command)-&gt; TransactionStatus{matchcmd{// Handle the `SetNote` command with one parameter Command::SetNote{note}=&gt;{// Simply increment the counter by some value letcurrent_user=AccountIdWrapper(origin.clone());// Insert the note, we only keep the latest note self.notes.insert(current_user,note);// Returns TransactionStatus::Ok to indicate a successful transaction TransactionStatus::Ok},}}} Now we can move to the GetNote handler. It's a little tricky since we only allow the owner of the note to access his note. In other words, we need to ensure that the user has signed the query, and then we respond with his note. For a signed query, the origin argument in handle_query method contains the account id of requester. We implement handle_query as shown below. It first checks if the query is signed by checking origin, and then returns the note stored in the contract states. It returns an NotAuthorized response if the query is not signed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /// Queries are not supposed to write to the contract states. #[derive(Serialize, Deserialize, Debug, Clone)]pubenum Request{/// Read the note for current user GetNote,}/// Query responses. #[derive(Serialize, Deserialize, Debug)]pubenum Response{/// Return the note for current user GetNote{note: String,},/// Something wrong happened Error(Error)}implcontracts::Contract&lt;Command,Request,Response&gt;forSecretNote{fn handle_query(&amp;mutself,origin: Option&lt;&amp;chain::AccountId&gt;,req: Request)-&gt; Response{letinner=||-&gt; Result&lt;Response,Error&gt;{matchreq{// Handle the `GetNote` request Request::GetNote=&gt;{// Unwrap the current user account ifletSome(account)=origin{letcurrent_user=AccountIdWrapper(account.clone());ifself.notes.contains_key(&amp;current_user){// Respond with the note in the notes letnote=self.notes.get(&amp;current_user);returnOk(Response::GetNote{note: note.unwrap().clone()})}}// Respond NotAuthorized when no account is specified Err(Error::NotAuthorized)},}};matchinner(){Err(error)=&gt;Response::Error(error),Ok(resp)=&gt;resp}}} Frontend Set note UI Query UI Handle error Put everything together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 useserde::{Serialize,Deserialize};usecrate::contracts;usecrate::types::TxRef;usecrate::TransactionStatus;usecrate::contracts::AccountIdWrapper;usecrate::std::collections::BTreeMap;usecrate::std::string::String;/// SecretNote contract states. #[derive(Serialize, Deserialize, Debug, Default)]pubstruct SecretNote{notes: BTreeMap&lt;AccountIdWrapper,String&gt;,}/// The commands that the contract accepts from the blockchain. Also called transactions. /// Commands are supposed to update the states of the contract. #[derive(Serialize, Deserialize, Debug)]pubenum Command{/// Set the note for current user SetNote{note: String,},}/// The errors that the contract could throw for some queries #[derive(Serialize, Deserialize, Debug)]pubenum Error{NotAuthorized,}/// Query requests. The end users can only query the contract states by sending requests. /// Queries are not supposed to write to the contract states. #[derive(Serialize, Deserialize, Debug, Clone)]pubenum Request{/// Read the note for current user GetNote,}/// Query responses. #[derive(Serialize, Deserialize, Debug)]pubenum Response{/// Return the note for current user GetNote{note: String,},/// Something wrong happened Error(Error)}implSecretNote{/// Initializes the contract pubfn new()-&gt; Self{Default::default()}}implcontracts::Contract&lt;Command,Request,Response&gt;forSecretNote{// Returns the contract id fn id(&amp;self)-&gt; contracts::ContractId{contracts::SECRET_NOTE}// Handles the commands from transactions on the blockchain. This method doesn&#39;t respond. fn handle_command(&amp;mutself,origin: &amp;chain::AccountId,_txref: &amp;TxRef,cmd: Command)-&gt; TransactionStatus{matchcmd{// Handle the `SetNote` command with one parameter Command::SetNote{note}=&gt;{// Simply increment the counter by some value letcurrent_user=AccountIdWrapper(origin.clone());// Insert the note, we only keep the latest note self.notes.insert(current_user,note);// Returns TransactionStatus::Ok to indicate a successful transaction TransactionStatus::Ok},}}// Handles a direct query and responds to the query. It shouldn&#39;t modify the contract states. fn handle_query(&amp;mutself,origin: Option&lt;&amp;chain::AccountId&gt;,req: Request)-&gt; Response{letinner=||-&gt; Result&lt;Response,Error&gt;{matchreq{// Handle the `GetNote` request Request::GetNote=&gt;{// Unwrap the current user account ifletSome(account)=origin{letcurrent_user=AccountIdWrapper(account.clone());ifself.notes.contains_key(&amp;current_user){// Respond with the note in the notes letnote=self.notes.get(&amp;current_user);returnOk(Response::GetNote{note: note.unwrap().clone()})}}// Respond NotAuthorized when no account is specified Err(Error::NotAuthorized)},}};matchinner(){Err(error)=&gt;Response::Error(error),Ok(resp)=&gt;resp}}} Summary In this tutorial, we have covered a walk-through for the HelloWorld contract template, and demostrate how we can build a bit more advanced contract SecretNote that leverages the confidentiality of Phala contract. Now it's your turn to build something new! Submit your work This tutorial is a part of Polkadot &quot;Hello World&quot; virtual hackathon challenge at gitcoin.co. In order to win the task, please do the followings: Fork the core blockchain and the Web UI repo (helloworld branch) into your own GitHub account Develop your own contract on the templates at “helloworld” branch (must be a different one from existing submissions) Launch your full development stack and take screenshots of your dapps Push your work to your forked repos. They must be open source Make a tweet with the link to your repos, the screenshots, and describe what you are building on Twitter Join our Discord server and submit the the link to your tweet]".toLowerCase(),});this.add({"id":"3","link":"https://wiki.phala.network/en-us/docs/troubleshooting/","title":"Troubleshooting","body":"[phala-blockchain Probelm: &quot;consider giving accuracy a type&quot; when building substrate error[E0282]: type annotations needed --&gt; .../substrate/primitives/arithmetic/src/fixed_point.rs:541:9 | 541 | let accuracy = P::ACCURACY.saturated_into(); | ^^^^^^^^ consider giving `accuracy` a type ... 1604 | / implement_fixed!( 1605 | | FixedI128, 1606 | | test_fixed_i128, 1607 | | i128, ... | 1611 | | [-170141183460469231731.687303715884105728, 170141183460469231731.687303715884105727]_&quot;, 1612 | | ); | |__- in this macro invocation | = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info) This is a known issue caused by rust nightly regression. To walkaround it, switch to an older nightly toolchain. We recommend nightly-2020-09-27. It can be done like below: 1 2 3 rustup toolchain install nightly-2020-09-27 rustup default nightly-2020-09-27 rustup target add wasm32-unknown-unknown --toolchain nightly-2020-09-27 Probelm: &quot;duplicate lang item&quot; error: duplicate lang item in crate `std`: `f32_runtime`. | = note: the lang item is first defined in crate `sgx_tstd` (which `enclaveapp` depends on) error: duplicate lang item in crate `std`: `f64_runtime`. | = note: the lang item is first defined in crate `sgx_tstd` (which `enclaveapp` depends on) error: duplicate lang item in crate `std`: `panic_impl`. | = note: the lang item is first defined in crate `sgx_tstd` (which `enclaveapp` depends on) error: duplicate lang item in crate `std`: `begin_panic`. | = note: the lang item is first defined in crate `sgx_tstd` (which `enclaveapp` depends on) error: duplicate lang item in crate `std`: `oom`. | = note: the lang item is first defined in crate `sgx_tstd` (which `enclaveapp` depends on) error: aborting due to 6 previous errors This is due to accidentally introduced &quot;std&quot; dependencies. Usually there are two common causes of this error. Most likely the code has some syntax errors and cannot build. Sometimes these errors can confuse the rust compiler in &quot;no_std&quot; mode and the compiler may accidentally introduce some random dependencies, which breaks our SDK. If this is the case, scroll up and fix the other compiling errors, and then this error should disappear. If fixing the other errors doesn't help, you should check if you accidentally introduce the &quot;std&quot; dependency to the runtime code. The hardware enclave sdk Phala is using doesn't allow direct or indirect &quot;std&quot; dependencies. You may consider to switch to a package that supports &quot;no_std&quot; and disable its std feature in Cargo.toml, or manually port the dependency package to use teaclave-sgx-sdk's tstd instead. tstd is a subset of std but it's enough in the most cases. apps-ng related Probelm: '@polkadot/dev/config/tsconfig' not found ready - started server on http://localhost:3000 error TS6053: File '@polkadot/dev/config/tsconfig' not found. You forgot to init the git submodule. Please run git submodule update --init.]".toLowerCase(),});this.add({"id":"4","link":"https://wiki.phala.network/en-us/docs/poc3/","title":"PoC-3 Vendetta Mining Guide","body":"[Vendetta is the thrid Phala Network Testnet featuring decentralized TEE mining. I. Get Started 1.1 Hardware Configuration 1.2 Software Configuration 1.3 Set Miner Stash II. Deploying Phala Docker 2.1 Deploy the Full Stack 2.2 Set Commission 2.3 Verify the Miner States III. Miner Operation 3.1 Set Miner Stakes 3.2 Starting Mining 3.3 Stop Mining 3.4 Check Miner Profits 3.5 Miner Upgrade IV. FAQ Frequently Asked Questions]".toLowerCase(),});this.add({"id":"5","link":"https://wiki.phala.network/en-us/docs/poc2/","title":"Legacy Docs (PoC-2)","body":"[Legacy Docs (PoC-2) Basics for Testnet PoC-2 Run a full node to support the network connectivity, or run a Gatekeeper to serve the network and earn rewards.]".toLowerCase(),});this.add({"id":"6","link":"https://wiki.phala.network/en-us/","title":"Phala Network Wiki","body":"[Phala Network Phala Network guarantees the reliable execution of smart contracts while keeping the data secretly. Confidential contracts run in TEE worker nodes with Trusted Computing capable hardwares, which guarantees the secrecy of the contract data. Docs Homepage Polkadot Hackathon]".toLowerCase(),});this.add({"id":"7","link":"https://wiki.phala.network/en-us/docs/poc2/run-a-gatekeeper/","title":"Run a Gatekeeper","body":"[This guide will instruct you how to set up a validator node on the Phala Network. Preliminaries Running a Gatekeeper on a live network is a lot of responsibility! You will be accountable for not only your own stake, but also the stake of your current nominators. If you make a mistake and get slashed, your money and your reputation will be at risk. However, running a Gatekeeper can also be very rewarding, knowing that you contribute to the security of a decentralized network while growing your stash. Since security is so important to running a successful Gatekeeper, you should take a look at Phala Network's the secure validator information to make you understand the factors to consider when constructing your infrastructure. The Web3 Foundation also maintains a reference implementation for a secure validator set-up that you can use by deploying yourself (video walkthrough is available here). As you progress in your journey as a Gatekeeper, you will likely want to use this repository as a starting point for your own modifications and customizations. If you need help, please reach out on the Phala Network Group on Telegram. The team and other Gatekeepers are there to help answer questions and provide experience. How many PHA do I need? You can have a rough estimate on that by using the methods listed here. Gatekeepers are elected based on Phragmen's algorithm. To be elected into the set, you need a minimum stake behind your Gatekeeper. This stake can come from yourself or from nominators. This means that as a minimum, you will need enough PHA to set up Stash and Controller accounts with the existential deposit, plus a little extra for transaction fees. The rest can come from nominators. Warning: Any PHA that you stake for your Gatekeeper is liable to be slashed, meaning that an insecure or improper setup may result in loss of PHA tokens! If you are not confident in your ability to run a Gatekeeper node, it is recommended to nominate your PHA to a trusted Gatekeeper node instead. Initial Set-up Requirements You will likely run your Gatekeeper on a server with TEE hardware running Linux. For this guide we will be using Ubuntu 18.04, but the instructions should be similar for other platforms. The transactions weights in Phala Network were benchmarked on standard hardware. It is recommended that Gatekeepers run at least the standard hardware in order to ensure they are able to process all blocks in time. The following are not minimum requirements but if you decide to run with less than this beware that you might have performance issue. Standard Hardware For the full details of the standard hardware please see here. CPU - 2 cores, with Intel SGX capability. Storage - A NVMe solid state drive. Should be reasonably sized to deal with blockchain growth. Starting around 80GB - 160GB will be okay for the first six months of Phala Network, but will need to be re-evaluated every six months. Memory - 2GB - 8GB. 2GB is really the minimum memory you should operate your Gatekeeper with, anything less than this make build times too inconvenient. For better performance you can bump it up to 4GB or 8GB, but anything more than that is probably over-kill. In order to compile the binary yourself you will likely need ~8GB. The specs posted above are by no means the minimum specs that you could use when running a Gatekeeper, however you should be aware that if you are using less you may need to toggle some extra optimizations in order to be equal to other Gatekeepers that are running the standard. Install Intel SGX driver &amp; platform software You can find the latest Linux SGX driver from the official download page. Make sure to install: SGX Linux DCAP Driver SGX Linux SDK (Under /opt) SGX Platform Swoftware The dockerfile offered by Teaclave SGX SDK is a good reference of how to install the SGX SDK and platform software. Though it's possible to run SGX apps inside Docker, we don't have a guide for it so far. The driver must be installed on host machine natively. Install the phala-node Binary Download the latest Phala Network binary from the Github release page. You can also build the phala-node binary from the Phala-Network/phala-blockchain repository on GitHub using the source code available in the master branch. You will need to prepare the rust build environment described in the Run a Full Node tutorial. Note: If you prefer to use SSH rather than HTTPS, you can replace the first line of the below with git clone git@github.com/Phala-Network/phala-blockchain.git. 1 2 3 4 5 git clone https://github.com/Phala-Network/phala-blockchain cd phala-blockchain ./scripts/init.sh git submodule update --init cargo build --release This step will take a while (generally 10 - 40 minutes, depending on your hardware). Note if you run into compile errors, you may have to switch to a less recent nightly. This can be done by running: 1 2 3 rustup install nightly-2020-05-15 rustup override set nightly-2020-05-15 rustup target add wasm32-unknown-unknown --toolchain nightly-2020-05-15 If you are interested in generating keys locally, you can also install subkey from the same directory. You may then take the generated subkey executable and transfer it to an air-gapped machine for extra security. 1 cargo install --force --git https://github.com/paritytech/substrate subkey Synchronize Chain Data Note: By default, Gatekeeper nodes are in archive mode. If you've already synced the chain not in archive mode, you must first remove the database with phala-node purge-chain and then ensure that you run Phala Network with the --pruning=archive option. You may run a Gatekeeper node in non-archive mode by adding the following flags: -unsafe-pruning --pruning OF BLOCKS&gt;, but note that an archive node and non-archive node's databases are not compatible with each other, and to switch you will need to purge the chain data. You can begin syncing your node by running the following command: 1 ./phala-node --pruning=archive if you do not want to start in Gatekeeper mode right away. The --pruning=archive flag is implied by the --validator and --sentry flags, so it is only required explicitly if you start your node without one of these two options. If you do not set your pruning to archive node, even when not running in Gatekeeper and sentry mode, you will need to re-sync your database when you switch. Note: Gatekeepers should sync using the RocksDb backend. This is implicit by default, but can be explicit by passing the --database RocksDb flag. In the future, it is recommended to switch to using the faster and more efficient ParityDb option. Switching between database backends will require a resync. If you want to test out ParityDB you can add the flag --database paritydb. Depending on the size of the chain when you do this, this step may take anywhere from a few minutes to a few hours. If you are interested in determining how much longer you have to go, your server logs (printed to STDOUT from the phala-node process) will tell you the latest block your node has processed and verified. You can then compare that to the current highest block via Telemetry or the Phala Web App. Note: If you do not already have PHA, this is as far as you will be able to go until the end of the soft launch period. You can still run a node, but you will need to have a minimal amount of PHA to continue, as balance transfers are disabled during the soft launch. Please keep in mind that even for those with PHA, they will only be indicating their intent to validate; they will also not be able to run a Gatekeeper until the NPoS phase starts. Bond PHA It is highly recommended that you make your controller and stash accounts be two separate accounts. For this, you will create two accounts and make sure each of them have at least enough funds to pay the fees for making transactions. Keep most of your funds in the stash account since it is meant to be the custodian of your staking funds. Make sure not to bond all your PHA balance since you will be unable to pay transaction fees from your bonded balance. It is now time to set up our Gatekeeper. We will do the following: Bond the PHA of the Stash account. These PHA will be put at stake for the security of the network and can be slashed. Select the Controller. This is the account that will decide when to start or stop validating. First, go to the Staking section. Click on &quot;Account Actions&quot;, and then the &quot;Stash&quot; button. Stash account - Select your Stash account. In this example, we will bond 100 milliPHA - make sure that your Stash account contains at least this much. You can, of course, stake more than this. Controller account - Select the Controller account created earlier. This account will also need a small amount of PHA in order to start and stop validating. Value bonded - How much PHA from the Stash account you want to bond/stake. Note that you do not need to bond all of the PHA in that account. Also note that you can always bond more PHA later. However, withdrawing any bonded amount requires the duration of the unbonding period. On Phala Network, the unbonding period is 7 days. Payment destination - The account where the rewards from validating are sent. More info here. Once everything is filled in properly, click Bond and sign the transaction with your Stash account. After a few seconds, you should see an &quot;ExtrinsicSuccess&quot; message. You should now see a new card with all your accounts (note: you may need to refresh the screen). The bonded amount on the right corresponds to the funds bonded by the Stash account. Set Session Keys Note: The session keys are consensus critical, so if you are not sure if your node has the current session keys that you made the setKeys transaction then you can use one of the two available RPC methods to query your node: hasKey to check for a specific key or hasSessionKeys to check the full session key public key string. Once your node is fully synced, stop the process by pressing Ctrl-C. At your terminal prompt, you will now start running the node in validator mode with a flag allowing unsafe RPC calls, needed for some advanced operations. 1 ./phala-node --validator --name &#34;name on telemetry&#34; You can give your Gatekeeper any name that you like, but note that others will be able to see it, and it will be included in the list of all servers using the same telemetry server. Since numerous people are using telemetry, it is recommended that you choose something likely to be unique. Generating the Session Keys You need to tell the chain your Session keys by signing and submitting an extrinsic. This is what associates your Gatekeeper node with your Controller account on Phala Network. Option 1: PolkadotJS-APPS You can generate your Session keys in the client via the apps RPC. If you are doing this, make sure that you have the PolkadotJS-Apps explorer attached to your Gatekeeper node. You can configure the apps dashboard to connect to the endpoint of your Gatekeeper in the Settings tab. If you are connected to a default endpoint hosted by Parity of Web3 Foundation, you will not be able to use this method since making RPC requests to this node would effect the local keystore hosted on a public node and you want to make sure you are interacting with the keystore for your node. Once ensuring that you have connected to your node, the easiest way to set session keys for your node is by calling the author_rotateKeys RPC request to create new keys in your Gatekeeper's keystore. Navigate to Toolbox tab and select RPC Calls then select the author &gt; rotateKeys() option and remember to save the output that you get back for a later step. Option 2: CLI If you are on a remote server, it is easier to run this command on the same machine (while the node is running with the default HTTP RPC port configured): 1 curl -H &#34;Content-Type: application/json&#34; -d &#39;{&#34;id&#34;:1, &#34;jsonrpc&#34;:&#34;2.0&#34;, &#34;method&#34;: &#34;author_rotateKeys&#34;, &#34;params&#34;:[]}&#39; http://localhost:9933 The output will have a hex-encoded &quot;result&quot; field. The result is the concatenation of the four public keys. Save this result for a later step. You can restart your node at this point, omitting the --unsafe-rpc-expose flag as it is no longer needed. Submitting the setKeys Transaction You need to tell the chain your Session keys by signing and submitting an extrinsic. This is what associates your validator with your Controller account. Go to Staking &gt; Account Actions, and click &quot;Set Session Key&quot; on the bonding account you generated earlier. Enter the output from author_rotateKeys in the field and click &quot;Set Session Key&quot;. Submit this extrinsic and you are now ready to start validating. Register TEE worker Gatekeepers utilize TEE to manage the secret keys in Phala Network. Before starting validating, you need to attach the TEE hardware to your Gatekeeper accounts. As long as the Gatekeeper is running and validating the blockchain, the TEE worker is always connected to the blockchain and support the network. The TEE worker is handled by two components: pHost and pRuntime. The latest prebuilt binaries can be found from the Github release page in tee-release.zip. Instead, you can also compile it on your own. Assuming you have extracted the prebuilt binares in a directory and have a running and fully synced phala-node, you can take the following steps to attach the TEE components to the blockchain: Start pRuntime: ./app Start pHost with proper flags: ./phost \ --mnemonic '&lt;the-mnenomic-of-your-controller-account&gt;' \ --no-sync \ --no-write-back \ --remote-attestation \ --substrate-ws-endpoint 'ws://localhost:9944' The mnenomic of your controller account is needed because phost will send transactions to register your TEE hardware on behalve of your controller account. The prebuilt release also includes bridge.sh, a convinient script to bring up phost in the same way described above. With the script file, you can save the mnemonic permanently, avoding typing it everytime you run it. Note: In Phala Network Testnet PoC-2, the TEE worker registration is an one-shot job. phost will exit right after a successful registeration. However in future version, since TEE supports the TEE network in the full life-time of a Gatekeeper, it must be always up and running until the Gatekeeper is retired. Validate To verify that your node is live and synchronized, head to Telemetry and find your node. Note that this will show all nodes on the Phala Network, which is why it is important to select a unique name! If everything looks good, go ahead and click on &quot;Validate&quot; in Phala Network UI. Payment preferences - You can specify the percentage of the rewards that will get paid to you. The remaining will be split among your nominators. Click &quot;Validate&quot;. Note: This step will fail if you haven't successfully registered a TEE worker on your controller account. Please double check Register TEE worker to make sure your TEE hardware is registered. If you go to the &quot;Staking&quot; tab, you will see a list of active Gatekeepers currently running on the network. At the top of the page, it shows the number of Gatekeeper slots that are available as well as the number of nodes that have signaled their intention to be a Gatekeeper. You can go to the &quot;Waiting&quot; tab to double check to see whether your node is listed there. The Gatekeeper set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the Gatekeeper set, your node will become an active Gatekeeper. Until then, it will remain in the waiting queue. If your Gatekeeper is not selected to become part of the Gatekeeper set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the Gatekeeper set in a particular era. However, it may be necessary to increase the number of PHA staked or seek out nominators for your Gatekeeper in order to join the Gatekeeper set. Congratulations! If you have followed all of these steps, and been selected to be a part of the Gatekeeper set, you are now running a Phala Network Gatekeeper! If you need help, reach out on the Phala Network Telegram group. Participate Testnet PoC-2 promotion events To participate the PoC-2 events, it's required to set your node name in the format below: 1 ./phala-node --name &#34;Name | Controller account address&#34; &lt;...other arguments&gt; Please see the chapter with the same name in Run a Full Node for more details. FAQ Why am I unable to synchronize the chain with 0 peers? Make sure to enable 30333 libp2p port. Eventually, it will take a little bit of time to discover other peers over the network. How do I clear all my chain data? 1 ./phala-node purge-chain]".toLowerCase(),});this.add({"id":"8","link":"https://wiki.phala.network/en-us/docs/poc2/run-a-full-node/","title":"Run a full node","body":"[If you're building dapps or products on a Phala Network, you probably want the ability to run a node-as-a-back-end. After all, it's always better to rely on your own infrastructure than on a third-party-hosted one in this brave new decentralized world. This guide will show you how to connect to Phala Network PoC-2. First, let's clarify the term full node. Types of Nodes A blockchain's growth comes from a genesis block, extrinsics, and events. When a Gatekeeper seals block 1, it takes the blockchain's state at block 0. It then applies all pending changes on top of it, and emits the events that are the result of these changes. Later, the state of the chain at block 1 is used in the same way to build the state of the chain at block 2, and so on. Once two thirds of the Gatekeepers agree on a specific block being valid, it is finalized. An archive node keeps all the past blocks. An archive node makes it convenient to query the past state of the chain at any point in time. Finding out what an account's balance at a certain block was, or which extrinsics resulted in a certain state change are fast operations when using an archive node. However, an archive node takes up a lot of disk space - around Kusama's 1.6 millionth block this was around 15 to 20GB. When running a Gatekeeper, this requirement doubles as the sentry node in front of a Gatekeeper should be an archive node too. A full node is pruned, meaning it discards all information older than 256 blocks, but keeps the extrinsics for all past blocks, and the genesis block. A node that is pruned this way requires much less space than an archive node. In order to query past state through a full node, a user would have to wait for the node to rebuild the chain up until that block. A full node can rebuild the entire chain with no additional input from other nodes and become an archive node. One caveat is that if finality stalled for some reason and the last finalized block is more than 256 blocks behind, a pruned full node will not be able to sync to the network. Archive nodes are used by utilities that need past information - like block explorers, council scanners, discussion platforms like Polkassembly, and others. They need to be able to look at past on-chain data. Full nodes are used by everyone else - they allow you to read the current state of the chain and to submit transactions directly to the chain without relying on a centralized infrastructure provider. Another type of node is a light node. A light node has only the runtime and the current state, but does not store past extrinsics and so cannot restore the full chain from genesis. Light nodes are useful for resource restricted devices. An interesting use-case of light nodes is a Chrome extension, which is a node in its own right, running the runtime in WASM format: https://github.com/paritytech/substrate-light-ui Fast Install Instructions (Linux) Not recommended if you're a Gatekeeper. Please see secure Gatekeeper setup For the most recent binary please see the release page on the phala-blockchain repository. The URL in the code snippet below may become slightly out-of-date. Also please note that the nature of pre-built binaries means that they may not work on your particular architecture or Linux distribution. If you see an error like cannot execute binary file: Exec format error it likely means the binary is not compatible with your system. You will either need to compile the source code yourself or use docker. Download Phala Network binary by running: curl -sL https://github.com/Phala-Network/phala-blockchain/releases/download/poc2-3.0-alpha1/phala-node -o phala-node Run the following: sudo chmod +x phala-node Run the following: ./phala-node --chain poc2 --name &quot;Your Node Name Here&quot; (check participating PoC-2 events for naming convention if you are) Find your node at https://telemetry.polkadot.io/#list/Phala%20PoC-2 Fast Install Instructions (Mac) Not recommended if you're a Gatekeeper. Please see secure Gatekeeper setup Type terminal in the macOS searchbar/searchlight to open the 'terminal' application Install Homebrew within the terminal by running: /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; Then run: brew install openssl cmake llvm Install Rust in your terminal by running: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh Once Rust is installed, run the following command to clone and build the Phala Network code: git clone https://github.com/Phala-Network/phala-blockchain cd phala-blockchain ./scripts/init.sh git submodule update --init cargo build --release Run the following command to start your node: ./target/release/phala-node --chain poc2 --name &quot;My node's name&quot; (check participating PoC-2 events for naming convention if you are) Find your node at https://telemetry.polkadot.io/#list/Phala%20PoC-2 Participate Testnet PoC-2 promotion events To participate the PoC-2 events, it's required to set your node name in the format below: 1 ./phala-node --name &#34;Name | Controller account address&#34; &lt;...other arguments&gt; where &quot;Controller account address&quot; is the address of your Controller account for staking (not Stash account). Please make sure there are two spaces close to the vertical bar symbol. Example: the command below brings up an archive node with the name &quot;PhalaMiner&quot; and its controller account 1 ./phala-node --name &#34;PhalaMiner | 5Ea32SkcVaEmBVFNeMycjuAQKNzHzwosFrhEhwUFmawsEtkt&#34; --pruning archive Get Substrate Follow instructions as outlined here - note that Windows users will have their work cut out for them. It's better to use a virtual machine instead. Test if the installation was successful by running cargo --version. 1 2 $ cargo --version cargo 1.41.0 (626f0f40e 2019-12-03) Clone and Build The Phala-Network/phala-blockchain repo's master branch contains the latest Phala Network code. 1 2 3 4 5 git clone https://github.com/Phala-Network/phala-blockchain cd phala-blockchain ./scripts/init.sh git submodule update --init cargo build --release Run The built binary will be in the target/release folder, called phala-node. 1 ./target/release/phala-node --chain poc2 --name &#34;My node&#39;s name&#34; Check participating PoC-2 events for naming convention if you are. Use the --help flag to find out which flags you can use when running the node. For example, if connecting to your node remotely, you'll probably want to use --ws-external and --rpc-cors all. The syncing process will take a while depending on your bandwidth, processing power, disk speed and RAM. On a $10 DigitalOcean droplet, the process can complete in some 36 hours. Congratulations, you're now syncing with Phala Network. Keep in mind that the process is identical when using any other Substrate chain. Running an Archive Node When running as a simple sync node (above), only the state of the past 256 blocks will be kept. When validating, it defaults to archive mode. To keep the full state use the --pruning flag: 1 ./target/release/phala-node --chain poc2 --name &#34;My node&#39;s name&#34; --pruning archive It is possible to almost quadruple synchronization speed by using an additional flag: --wasm-execution Compiled. Note that this uses much more CPU and RAM, so it should be turned off after the node is in sync. Using Docker Finally, you can use Docker to run your node in a container. Doing this is a bit more advanced so it's best left up to those that either already have familiarity with docker, or have completed the other set-up instructions in this guide. The reference docker file is located here. Please note that by default the docker file only spawn a two nodes local testnet node, not a single node connecting to the public blockchain. This is mainly used for development. You can create your own docker file for connecting to Phala Network PoC2.]".toLowerCase(),});this.add({"id":"9","link":"https://wiki.phala.network/en-us/docs/poc3/1-1-hardware-configuration/","title":"1.1 Hardware Configuration","body":"[How to check whether your device is SGX-supported: Whether your hardware CPU is SGX-supported Refer to the SGX Hardware List Take the SGX Test BIOS Settings Google how to enter your BIOS Settings. Enter BIOS after reboot. Go to Security -&gt; Secure Boot, set it to Disabled. Go to Security -&gt; SGX, set it to Enabled (or any other option that is similar as the description varies according to different manufacturers.) Go to Boot -&gt; Boot Mode, set it to UEFI. Press F10 and wait for rebooting. Reference What is Trusted Execution Environment What is SGX]".toLowerCase(),});this.add({"id":"10","link":"https://wiki.phala.network/en-us/docs/poc3/1-2-software-configuration/","title":"1.2 Software Configuration","body":"[Ubuntu 18.04 Versions other than 18.04 are not supported. How to intsall Make all your packages up-to-date: type sudo apt update &amp;&amp; sudo apt upgrade -y &amp;&amp; sudo apt autoremove -y in the terminal. How to open your Terminal: right click on your desktop → Open in Terminal Install SGX driver If you have already installed the SGX driver, you can verify by: Type ls /dev | grep sgx in the terminal If there's any output, your SGX driver is ready. If there's no output, you have to download and install it. And verify it again. For FLC ready CPUs and motherboards, the DCAP driver is preferred. Othrewise insall the SGX driver. Install Docker-CE Use commands as below in the terminal: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &quot;deb [arch=amd64] &lt;https://download.docker.com/linux/ubuntu&gt; $(lsb_release -cs) stable&quot; sudo apt-get install -y docker-ce docker-ce-cli containerd.io sudo usermod -aG docker [YOUR_UBUNTU_USERNAME] (Replace &quot;[YOUR_UBUNTU_USERNAME]&quot; to the user name you are using, without the brackets) This is how it looks like after it's successfully deployed👇. Reference: Install Docker Engine on Ubuntu]".toLowerCase(),});this.add({"id":"11","link":"https://wiki.phala.network/en-us/docs/poc3/1-3-set-miner-stash/","title":"1.3 Set Miner Stash","body":"[Conneting to Testnet Vendetta Open the Phala Network PoC-3 Web UI at: https://poc3.phala.network Creating Phala Accounts You may refer to this tutorial. Tip: to better manage your stash accounts and according controller accounts, we suggested you naming an account paired with the same prefix. E.g., Emily Stash / Emily Controller Obtaining tPHA Please be aware that you will need to burn ERC20 PHA to obtain tPHA on testnet Vendetta. 0.1 ERC20 = 100 tPHA. tPHA has no value and CANNOT be exchanged back to ERC20 or mainnet PHA. You may refer to this tutorial. Setting Miner Stash Go to Developer → Extrinsics (or click here) Choose phalaModule → SetStash(controller) Select your STASH account in the first line, and your CONTROLLER account in the third line. Submit Transaction, sign it and wait for the broadcast.]".toLowerCase(),});this.add({"id":"12","link":"https://wiki.phala.network/en-us/docs/poc3/2-1-deploy-the-full-stack/","title":"2.1 Deploy the Full Stack","body":"[ALERT: Operations at this step may reset your previous Phala blockchain data and you will need to re-deploy the mirror files. For more detail, refer to: https://github.com/Phala-Network/phala-docker#usage PLEASE DO NOT change the order when deploying the three docker containers below. Deploying Phala full-node A Phala full-node helps maintains the backbone of the network. We suggest you to run a Phala full-node on a device with 50+ GB storage. What is a full-node Open the Terminal, and use the commands as follow. Your node name will be set by the second line. sudo docker pull jasl123/phala-poc3-node (to pull a docker file) sudo docker run -ti --rm --name phala-node -d -e NODE_NAME=&quot;YOUR_NODE_NAME&quot; -p 9933:9933 -p 9944:9944 -p 30333:30333 -v $HOME/phala-node-data:/root/data jasl123/phala-poc3-node (to run the docker file; please repalce YOUR_NODE_NAME with your own name, only alhpabets, digits and whitespace are supported) The docker container will start after these two commands. To stop or restart it, please refer to this tutorial. You can stop the full node by sudo docker kill phala-node. Please avoid irregular turning down of the container （e.g., turn off or reboot your computer without stopping it). It may cause damage to the blockchain database, which can only be solved by re-sync of the entire blockchain. If you are planning to run multiple full-nodes on one device (which is not suggested), please set different database path for each node by changing $HOME/phala-node-data to some other directory. Deploying pRuntime sudo docker pull jasl123/phala-poc3-node sudo docker run -d -ti --rm --name phala-pruntime -p 8000:8000 -v $HOME/phala-pruntime-data:/root/data --device /dev/isgx jasl123/phala-poc3-pruntime If there is no output, please refer to the FAQ. $HOME/phala-pruntime-data is the default path to the data of pRuntime. It's set in the phala-pruntime-data folder by default, which can be changed to another folder that the system admin has full access to. To run multiple pRuntime containers on one device (which is unecessary and not suggested), please set different path for each container. If the data was deleted, please re-register the miner from the beginning. Deploying pHost Please replace the YOUR-CONTROLLER-MNEMONIC in the second command with the mnemonic of your controller. If you didn't fill in mnemonic at this step, you would receive &quot;NotController&quot; error when submitting transactions related to phalaModule: setStash(controller). It costs a tiny amount of tPHA as well. Before deploying pHost, please make sure there are a certain amount of tPHA in your Stash account and controller account. Click here to learn how to obtain tPHA. sudo docker pull jasl123/phala-poc3-phost sudo docker run -d -ti --rm --name phala-phost -e PRUNTIME_ENDPOINT=&quot;http://IP-ADDRESS:8000&quot; -e PHALA_NODE_WS_ENDPOINT=&quot;ws://IP-ADDRESS:9944&quot; -e MNEMONIC=&quot;YOUR-CONTROLLER-MNEMONIC&quot; -e EXTRA_OPTS=&quot;-r&quot; jasl123/phala-poc3-phost The docker contanier will start to run after the input of these two commands. To stop or restart it, please refer to the tutorial. If you reboot the pRuntime container, you will have to reboot the pHost as well. http://IP-ADDRESS:8000 is the address listened by pRuntime. And ws://IP-ADDRESS:9944 is the WebSocker address of Phala full-node. They have to replace IP-ADDRESS by the IP address of your host machine instead of the localhost (e.g. 127.0.0.1) You can find your IP address by ip addr command.]".toLowerCase(),});this.add({"id":"13","link":"https://wiki.phala.network/en-us/docs/poc3/2-2-set-commission/","title":"2.2 Set Commission","body":"[Go to Developer -&gt; Extrinsics. Choose your Controller account -&gt; phalaModule -&gt; setPayoutPrefs(payout_comission, payout_target) Fill in commission (from 0 to 100) and choose the account where you want to receive the mining rewards at target. The commission rate influences your final return. For any mining reward you get, you always take the commission from it, and then distribute the rests propotionally to the mining stakers. Of course you get all if it's all your own stake. A lower commission rate will share more of your profits, which means more lenders are likely to support you and lower your staking amount.]".toLowerCase(),});this.add({"id":"14","link":"https://wiki.phala.network/en-us/docs/poc3/2-3-veirfy-the-miner-state/","title":"2.3 Veirfy the Miner State","body":"[Go to Developer -&gt; Chain state : Check miner score: phalaModule - &gt;workerState -&gt; choose your stash account score.overallScore: the total points that a miner scores features: number of enabled cores, and the level of your cores（1-4）. Check stash state: stashState Confirm the binding between stash and controller addresses: phalaModule.stash(controller) An example of all the details of mining state is shown below:]".toLowerCase(),});this.add({"id":"15","link":"https://wiki.phala.network/en-us/docs/poc3/3-1-set-miner-stakes/","title":"3.1 Set Miner Stakes","body":"[As designed in Phala Token Economics, each miner is required to stake at least 1620 PHA per core before mining starts. On testnet Vendetta, to better perform a stress test on Phala network and allow more miners to participate, Phala network will automatically stake for miners after they register. However, to score a higher rank in the Miner Race, you can earn more points by using better hardwares, staking more tPHA, or simply running for a longer period, e.t.c.. Rules and tutorials of how to stake more PHA to your miner will be published soon before the race is launched. The Mining Lending Protocol This protocol is designed to lowered the entrance cost of staking: a miner may turn to other PHA holders, and invite them to stake for him or her. Thus he or she could start mining with less cost. As a payback, part of the mining profits will be shared with the nominators. The detailed introduction and tutorial of Mining Nomination will be published shortly.]".toLowerCase(),});this.add({"id":"16","link":"https://wiki.phala.network/en-us/docs/poc3/3-2-start-mining/","title":"3.2 Start Mining","body":"[Go to Develoepr -&gt; Extrinsics Choose your controller account，click phalaModule -&gt; startMiningIntention() ，and Submit Transaction. Then you will wait for the next mining period (every 1 hour) to get started. Mining States Verification Go to Developer → Chain State Click phalaModule → miningState Choose your stash account]".toLowerCase(),});this.add({"id":"17","link":"https://wiki.phala.network/en-us/docs/poc3/3-3-stop-mining/","title":"3.3 Stop Mining","body":"[Go to Developer → Extrinsics Choose your controller account，clickphalaModule → stopMiningIntention() → Submit Transaction Then you will wait for the next mining period (every 1 hour) to get stopped. Miner State Verification Go toDeveloper → Chain State phalaModule → workerState → Stash account phalaModule → miningState → Stash account]".toLowerCase(),});this.add({"id":"18","link":"https://wiki.phala.network/en-us/docs/poc3/3-4-check-mining-profits/","title":"3.4 Check Miner Profits","body":"[Go to Developer → Chain State Click phalaModule → credits → choose your stash account]".toLowerCase(),});this.add({"id":"19","link":"https://wiki.phala.network/en-us/docs/poc3/3-5-upgrade-miner/","title":"3.5 Upgrade Miner","body":"[Stop Mining If your miner is not mining, please go to step 2. Refer to this link to stop mining. Wait until the end of the current mining period (1 hour per mining period). If you stop the miner too early, you may get slashed. Run the following commands: 1 2 3 4 docker kill phala-phost docker kill phala-pruntime docker kill phala-node sudo docker image prune -a # type `y` to confirm the deletion Reset Docker Containers sudo rm -rf /PATH/TO/YOUR/phala-node-data By default, the Phala node data is stored under $HOME/phala-node-data Type commands as follows 1 2 3 sudo docker pull jasl123/phala-poc3-node sudo docker pull jasl123/phala-poc3-pruntime sudo docker pull jasl123/phala-poc3-phost Type commands as follows: 1 2 3 4 5 6 # start the full node sudo docker run -ti --rm --name phala-node -d -e NODE_NAME=YOUR_NODE_NAME -p 9933:9933 -p 9944:9944 -p 30333:30333 -v $HOME/phala-node-data:/root/data jasl123/phala-poc3-node # start pRuntime sudo docker run -d -ti --rm --name phala-pruntime -p 8000:8000 -v $HOME/phala-pruntime-data:/root/data --device /dev/isgx jasl123/phala-poc3-pruntime # start the bridge (wait for 30s after started the full node and pRuntime) sudo docker run -d -ti --rm --name phala-phost -e PRUNTIME_ENDPOINT=&#34;http://IP-ADDRESS:8000&#34; -e PHALA_NODE_WS_ENDPOINT=&#34;ws://IP-ADDRESS:9944&#34; -e MNEMONIC=&#34;THE-MNEMONIC-OF-YOUR-CONTROLLER&#34; -e EXTRA_OPTS=&#34;-r&#34; jasl123/phala-poc3-phost Restart Mining Refer to 3.2 Start Mining.]".toLowerCase(),});this.add({"id":"20","link":"https://wiki.phala.network/en-us/docs/poc3/4-faq/","title":"4 Frequently Asked Questions","body":"[Q: It says &quot;no such command&quot; after I typed docker pull docker.pkg.github.com/phala-network/phala-docker/phala-node:pre-test-4 Please check the installation of Docker-CE. Q: It says &quot;permission denied&quot; Add sudo in front of your commands. Q: How to check if my installed driver is SGX or DCAP Run ls /dev/isgx and if the file exists: SGX-driver Run ls /dev/sgx and if the directory exists: DCAP-driver]".toLowerCase(),});this.add({"id":"21","link":"https://wiki.phala.network/en-us/categories/","title":"Categories","body":"[]".toLowerCase(),});this.add({"id":"22","link":"https://wiki.phala.network/en-us/tags/","title":"Tags","body":"[]".toLowerCase(),});});const simpleIndex=[{id:0,link:"https://wiki.phala.network/en-us/docs/",title:"Overview",},{id:1,link:"https://wiki.phala.network/en-us/docs/run-a-local-development-network/",title:"Run a Local Development Network",},{id:2,link:"https://wiki.phala.network/en-us/docs/your-first-confidential-contract/",title:"Hello World: your first confidential contract",},{id:3,link:"https://wiki.phala.network/en-us/docs/troubleshooting/",title:"Troubleshooting",},{id:4,link:"https://wiki.phala.network/en-us/docs/poc3/",title:"PoC-3 Vendetta Mining Guide",},{id:5,link:"https://wiki.phala.network/en-us/docs/poc2/",title:"Legacy Docs (PoC-2)",},{id:6,link:"https://wiki.phala.network/en-us/",title:"Phala Network Wiki",},{id:7,link:"https://wiki.phala.network/en-us/docs/poc2/run-a-gatekeeper/",title:"Run a Gatekeeper",},{id:8,link:"https://wiki.phala.network/en-us/docs/poc2/run-a-full-node/",title:"Run a full node",},{id:9,link:"https://wiki.phala.network/en-us/docs/poc3/1-1-hardware-configuration/",title:"1.1 Hardware Configuration",},{id:10,link:"https://wiki.phala.network/en-us/docs/poc3/1-2-software-configuration/",title:"1.2 Software Configuration",},{id:11,link:"https://wiki.phala.network/en-us/docs/poc3/1-3-set-miner-stash/",title:"1.3 Set Miner Stash",},{id:12,link:"https://wiki.phala.network/en-us/docs/poc3/2-1-deploy-the-full-stack/",title:"2.1 Deploy the Full Stack",},{id:13,link:"https://wiki.phala.network/en-us/docs/poc3/2-2-set-commission/",title:"2.2 Set Commission",},{id:14,link:"https://wiki.phala.network/en-us/docs/poc3/2-3-veirfy-the-miner-state/",title:"2.3 Veirfy the Miner State",},{id:15,link:"https://wiki.phala.network/en-us/docs/poc3/3-1-set-miner-stakes/",title:"3.1 Set Miner Stakes",},{id:16,link:"https://wiki.phala.network/en-us/docs/poc3/3-2-start-mining/",title:"3.2 Start Mining",},{id:17,link:"https://wiki.phala.network/en-us/docs/poc3/3-3-stop-mining/",title:"3.3 Stop Mining",},{id:18,link:"https://wiki.phala.network/en-us/docs/poc3/3-4-check-mining-profits/",title:"3.4 Check Miner Profits",},{id:19,link:"https://wiki.phala.network/en-us/docs/poc3/3-5-upgrade-miner/",title:"3.5 Upgrade Miner",},{id:20,link:"https://wiki.phala.network/en-us/docs/poc3/4-faq/",title:"4 Frequently Asked Questions",},{id:21,link:"https://wiki.phala.network/en-us/categories/",title:"Categories",},{id:22,link:"https://wiki.phala.network/en-us/tags/",title:"Tags",},];function searchResults(results=[],order=[],query=""){let resultsFragment=new DocumentFragment();let showResults=elem('.search_results');emptyEl(showResults);let index=0
if(results.length){let resultsTitle=createEl('h3');resultsTitle.className='search_title';resultsTitle.innerText='Quick Links';resultsFragment.appendChild(resultsTitle);results.slice(0,6).forEach(function(result){let item=createEl('a');item.href=`${result.link}?query=${query}`;item.className='search_result';item.textContent=result.title;item.style.order=order[index];resultsFragment.appendChild(item);index+=1});}else{showResults.innerHTML="";}
showResults.appendChild(resultsFragment);}
function search(){const searchField=elem('.search_field');if(searchField){searchField.addEventListener('input',function(event){const searchTerm=this.value.trim().replaceAll(" "," +").toLowerCase();if(searchTerm.length>=3){let rawResults=idx.search(`+${searchTerm}`);console.log(rawResults,searchTerm);if(rawResults.length){let refs=rawResults.map(function(ref){return `${ref.ref}:${ref.score}`;});let ids=refs.map(function(id){let positionOfSeparator=id.indexOf(":");id=id.substring(0,positionOfSeparator)
return Number(id);});let scores=refs.map(function(score){let positionOfSeparator=score.indexOf(":");score=score.substring((positionOfSeparator+1),(score.length-1));return(parseFloat(score)*50).toFixed(0);});console.log(scores,'scores is');let matchedDocuments=simpleIndex.filter(function(doc){return ids.includes(doc.id);});console.log('matches are',matchedDocuments);matchedDocuments.length>=1?searchResults(matchedDocuments,scores,searchTerm):false;}else{searchResults();}}else{searchResults();}});}}
let alltext=doc.innerHTML;console.log(typeof alltext);window.addEventListener('load',()=>search());